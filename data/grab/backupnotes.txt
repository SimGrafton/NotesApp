{"To do":{"Today":{},"Training Notes":{"Add btn Export to Excel":{"Info":"","Code":""},"Method to reorder":{"Info":"","Code":""}},"To learn":{"Co-routine":{"Info":"","Code":""},"Move Semantics":{"Info":"","Code":""}}},"C++ Concepts":{"Polymorphism":{"Polymorphism":{"Info":"Virtual Function:\r\n\r\nA virtual function is declared by keyword virtual. The return type of virtual function may be int, float, void.\r\n\r\nA virtual function is a member function in the base class. We can redefine it in a derived class. It is part of run time polymorphism. The declaration of the virtual function must be in the base class by using the keyword virtual. A virtual function is not static. \r\n\r\nThis is so that we can use a pointer to the base class and the base class can specify that the ??","Code":""},"henolo":{"Info":"Compile Time Polymorphism:\r\n\r\nIn compile-time polymorphism, a function is called at the time of program compilation. We call this type of polymorphism as early binding or Static binding.\r\n\r\nFunction overloading and operator overloading is the type of Compile time polymorphism. (See sections within functions and operators on overloading).","Code":""},"Definono":{"Info":"Polymorphism in C++:\r\n\r\nThe same entity ( function or object ) behaves differently in different scenarios.\r\n\r\nThere are 2 types of polymorphism:\r\n- Compile Time, which includes Function and Operator overloading and \r\n- Runtime, which includes virtual functions.\r\n\r\nFor example, the \u001c+\u001d operator in c++ can perform two specific functions at two different scenarios i.e when the \u001c+\u001d operator is used in numbers, it performs addition, but when used on strings, it performs concatenation. So the function that is called is determined by the data type of the variable that is passed. \r\n\r\nThe concept of polymorphism where a pointer of a base class can actually point to either the base class, or to one of the derived classes. Polymorphism allows us to create consistent code.\r\n\r\nA class with animal as the base class and tiger, cat as the derived classes, if you have a pointer of type Animal* then it can point to Animal, Tiger or Cat. The pointer type being the same type as the base class allows this.\r\n\r\nAn example of Compile-time polymorphism is where the compiler chooses which function to execute depending on the parameters passed, for example if we had int sum (int i, int j) {return i + j} and int sum (int i, int j, int p) { return i*j*p}. If we call sum(1,2) it will add the 2, if we call sum(1,2,3) it will time the 3 together.\u0000","Code":"\u0000"}},"Scope":{"Definition":{"Info":"The region in which an object exists and can use the variable. Either an entire .cpp file or anything in code delimited by {}. After brackets the variable is destroyed allowing the memory it was using to be reallocated. Destructors is then called. Can use () wherever to return memory but will then run the destructors when variable is destroyed.\r\n\r\nThe scope of a variable is only applicable to the section within brackets its in unless you return it using return types","Code":""}},"Keywords":{"Definition":{"Info":"Keywords are predefined reserved identifiers that have special meanings. They can't be used as identifiers in your program","Code":""},"Const":{"Info":"Const:\r\nThe const keyword specifies that a variable's value is constant and tells the compiler to prevent the programmer from modifying it. ... For objects that are declared as const , you can only call constant member functions. This ensures that the constant object is never modified.\r\n\r\nIn C++, you can use the const keyword instead of the #define preprocessor directive to define constant values. Values defined with const are subject to type checking, and can be used in place of constant expressions. \r\n\r\nConstexpr vs Const:\r\nConstexpr is used during compile time. This means that when you use constexpr to define some constant primitive value, you suggest that this symbol will be used in a constexpr function. If you're using a constant primitive value that is not used in any constexpr functions, use standard const, so that after quick glance over a symbol, reviewer will know that there is no constexpr function used with this particular symbol. Constexpr is a tool built for specific purposes, and while it fits in some of the cases where simple const would work, it shouldn\u0019t be used interchangeably.\r\n\r\n\u0000","Code":"\u0000"},"Constexpr":{"Info":"Constexpr:\r\nconst applies for variables, and prevents them from being modified in your code.\r\n\r\nconstexpr tells the compiler that this expression results in a compile time constant value, so it can be used in places like array lengths, assigning to const variables, etc. The link given by Oli has a lot of excellent examples.\r\n\r\nThe keyword constexpr was introduced in C++11 and improved in C++14. It means constant expression. Like const, it can be applied to variables: A compiler error is raised when any code attempts to modify the value. Unlike const, constexpr can also be applied to functions and class constructors. constexpr indicates that the value, or return value, is constant and, where possible, is computed at compile time.\r\n\r\nA constexpr integral value can be used wherever a const integer is required, such as in template arguments and array declarations. And when a value is computed at compile time instead of run time, it helps your program run faster and use less memory.\r\n\r\nTo limit the complexity of compile-time constant computations, and their potential impacts on compilation time, the C++14 standard requires the types in constant expressions to be literal types.\r\n\r\nBenefits:\r\nIncreases runtime efficiency by moving things from runtime to compile time\r\nSImplify code through compile time computation\r\n\r\nSo, why do we need constexpr?\r\nThe primary usage of constexpr is to declare intent.\r\n\r\nIf an entity isn't marked as constexpr - it was never intended to be used in a constant-expression; and even if it is, we rely on the compiler to diagnose such context (because it disregards our intent).\r\n\r\n\u0000","Code":"Suppose it does something a little more complicated.\r\n\r\nconstexpr int MeaningOfLife ( int a, int b ) { return a * b; }\r\n\r\nconst int meaningOfLife = MeaningOfLife( 6, 7 );\r\n\r\nNow you have something that can be evaluated down to a constant while maintaining good readability and allowing slightly more complex processing than just setting a constant to a number.\r\n\r\nIt basically provides a good aid to maintainability as it becomes more obvious what you are doing. Take max( a, b ) for example:\r\n\r\ntemplate< typename Type > constexpr Type max( Type a, Type b ) { return a < b ? b : a; }\r\n\r\nIts a pretty simple choice there but it does mean that if you call max with constant values it is explicitly calculated at compile time and not at runtime.\r\n\r\nAnother good example would be a DegreesToRadians function. Everyone finds degrees easier to read than radians. While you may know that 180 degrees is 3.14159265 (Pi) in radians it is much clearer written as follows:\r\n\r\nconst float oneeighty = DegreesToRadians( 180.0f );\u0000"},"This":{"Info":"Key word, to refer to an object which is part of a class. this->name = name; stops from having to refer to a new name each time. Need to know pointers to fully understand. this is a variable containing memory location of each individual object that you create and called a pointer variable. This specifies memory section allocated.\u0000","Code":"\u0000"}},"Preprocessor Directives":{"Definition":{"Info":"A preprocessor (or precompiler) is a program that processes its input data to produce output that is used as input to another program. The output is said to be a preprocessed form of the input data, which is often used by some subsequent programs like compilers. The amount and kind of processing done depends on the nature of the preprocessor; some preprocessors are only capable of performing relatively simple textual substitutions and macro expansions, while others have the power of full-fledged programming languages.\u0000","Code":"\u0000"},"Linkage":{"Info":"Internal and External Linkage:\r\n\r\nWhen you write an implementation file (.cpp, .cxx, etc) your compiler generates a translation unit. This is the source file from your implementation plus all the headers you #included in it.\r\n\r\nInternal linkage refers to everything only in scope of a translation unit.\r\n\r\nExternal linkage refers to things that exist beyond a particular translation unit. In other words, accessible through the whole program, which is the combination of all translation units (or object files).\r\n\r\nAnother def:\r\nexternal linkage means the symbol (function or global variable) is accessible throughout your program and internal linkage means that it is only accessible in one translation unit.\r\n\r\nYou can explicitly control the linkage of a symbol by using the extern and static keywords. If the linkage is not specified then the default linkage is extern (external linkage) for non-const symbols and static (internal linkage) for const symbols.\r\n\r\nNote that instead of using static (internal linkage), it is better to use anonymous namespaces into which you can also put classes. Though they allow extern linkage, anonymous namespaces are unreachable from other translation units, making linkage effectively static.\r\n\u0000","Code":"// In namespace scope or global scope.\r\nint i; // extern by default\r\nconst int ci; // static by default\r\nextern const int eci; // explicitly extern\r\nstatic int si; // explicitly static\r\n\r\n// The same goes for functions (but there are no const functions).\r\nint f(); // extern by default\r\nstatic int sf(); // explicitly static \r\n\r\nnamespace {\r\n  int i; // extern by default but unreachable from other translation units\r\n  class C; // extern by default but unreachable from other translation units\r\n}\u0000"},"#Using":{"Info":"\u000bThe using keyword is used to:\r\n\r\nBring a specific member from the namespace into the current scope.\r\nBring all members from the namespace into\u000b the current scope.\r\nBring a base class method \u000bor variable into the current class\u0019s scope.\u0000","Code":"#using namespace std;\r\n\r\ncout << \"Hello World\" << endl; \r\n\r\nInstead of:\r\nstd::cout << \"Hello World\" << std::endl; \u0000"},"#Define":{"Info":"","Code":""},"Other directives":{"Info":"#elif\r\n#else\r\n#endif\r\n#error\r\n#if\r\n#ifdef\r\n#ifndef\r\n#import\r\n#include\r\n#line\r\n#pragma\r\n#undef","Code":""},"Include Guards":{"Info":"Just use #pragma once. We don\u0019t have to use #define-based include guards, because every C++ compiler supports #pragma once. I don\u0019t know of any compiler that doesn\u0019t support #pragma once.\u0000","Code":"#pragma once\u0000"}},"Compiling and Building":{"Translation Units":{"Info":"In C and C++ programming language terminology, a translation unit (or more casually a compilation unit) is the ultimate input to a C or C++ compiler from which an object file is generated.[1] A translation unit roughly consists of a source file after it has been processed by the C preprocessor, meaning that header files listed in #include directives are literally included, sections of code within #ifndef may be included, and macros have been expanded.\r\n\r\nA C program consists of units called source files (or preprocessing files), which, in addition to source code, includes directives for the C preprocessor. A translation unit is the output of the C preprocessor \u0013 a source file after it has been preprocessed.\u0000","Code":"\u0000"},"Process":{"Info":"Stage 1 = Pre-processing time\r\n\r\nStage 2 - Compiling Time\r\n\r\n\r\n\r\nSource Code: \r\nThis is the code that you write into .cpp and .h files\u0000","Code":"\u0000"}},"Macros":{"Definition":{"Info":"A macro is a fragment of code which has been given a name. Whenever the name is used, it is replaced by the contents of the macro. There are two kinds of macros. They differ mostly in what they look like when they are used. Object-like macros resemble data objects when used, function-like macros resemble function calls.\r\n\r\nYou may define any valid identifier as a macro, even if it is a C keyword. The preprocessor does not know anything about keywords. This can be useful if you wish to hide a keyword such as const from an older compiler that does not understand it. However, the preprocessor operator defined (see Defined) can never be defined as a macro, and C++\u0019s named operators (see C++ Named Operators) cannot be macros when you are compiling C++.\r\n\r\nMacros are created using #define.\r\n\r\nDO NOT USE IF POSSIBLE - Better alternative for a macro is a constexpr function. If you can implement the logic with a constexpr function instead of a macro, use constexpr function. Biggest issue with macros is that they can\u0019t be namespaced. If you declare a macro then you\u0019re stick with the name no matter what. Maybe it\u0019s not a problem for you right now, but it will be a problem at some point in the future.\u0000","Code":"\u0000"},"Object-like Macros":{"Info":"An object-like macro is a simple identifier which will be replaced by a code fragment. It is called object-like because it looks like a data object in code that uses it. They are most commonly used to give symbolic names to numeric constants.\r\n\r\nYou create macros with the \u0018#define\u0019 directive. \u0018#define\u0019 is followed by the name of the macro and then the token sequence it should be an abbreviation for, which is variously referred to as the macro\u0019s body, expansion or replacement list. For example,\r\n\r\n#define BUFFER_SIZE 1024\r\ndefines a macro named BUFFER_SIZE as an abbreviation for the token 1024. If somewhere after this \u0018#define\u0019 directive there comes a C statement of the form\r\n\r\nfoo = (char *) malloc (BUFFER_SIZE);\r\nthen the C preprocessor will recognize and expand the macro BUFFER_SIZE. The C compiler will see the same tokens as it would if you had written\r\n\r\nfoo = (char *) malloc (1024);\r\nBy convention, macro names are written in uppercase. Programs are easier to read when it is possible to tell at a glance which names are macros.","Code":""},"Function-like Macros":{"Info":"You can also define macros whose use looks like a function call. These are called function-like macros. To define a function-like macro, you use the same \u0018#define\u0019 directive, but you put a pair of parentheses immediately after the macro name. For example,\r\n\r\n#define lang_init()  c_init()\r\nlang_init()\r\n       c_init()\r\nA function-like macro is only expanded if its name appears with a pair of parentheses after it. If you write just the name, it is left alone. This can be useful when you have a function and a macro of the same name, and you wish to use the function sometimes.\r\n\r\nextern void foo(void);\r\n#define foo() /* optimized inline version */\r\n\r\nFunction-like macros can take arguments, just like true functions. To define a macro that uses arguments, you insert parameters between the pair of parentheses in the macro definition that make the macro function-like. The parameters must be valid C identifiers, separated by commas and optionally whitespace.\u0000","Code":"As an example, here is a macro that computes the minimum of two numeric values, as it is defined in many C programs, and some uses.\r\n\r\n#define MAX(a, b) (a > b ? a : b)\r\n\r\nIn this example, the expression a > b is evaluated. If it evaluates to true then a is returned. If it evaluates to false, b is returned. Therefore, the line MAX(4, 12); evaluates to 12. \r\n\r\n(full version in example is #define MAX(a, b) (((a) > (b)) ? (a) : (b)); but above is easier to read).\r\n\r\nYou can use this to pick which value to assign to a variable:\r\nint foo = (bar > bash) ? bar : bash;\r\nIn this example, either 'bar' or 'bash' is assigned to 'foo', depending on which is bigger.\r\n\r\nOr even which variable to assign a value to:\r\n((bar > bash) ? bar : bash) = foo;\r\nHere, 'foo' is assigned to 'bar' or 'bash', again depending on which is bigger.\u0000"}},"Operators":{"Definition":{"Info":"","Code":""},"Conditional/ Ternary":{"Info":"The conditional operator is an operator used in C and C++ (as well as other languages, such as C#). The ?: operator returns one of two values depending on the result of an expression.\r\n\r\nSyntax\r\n\r\n(expression 1) ? expression 2 : expression 3\r\nIf expression 1 evaluates to true, then expression 2 is evaluated.\r\n\r\nIf expression 1 evaluates to false, then expression 3 is evaluated instead.\u0000","Code":"#define MAX(a, b) (((a) > (b)) ? (a) : (b))\r\nIn this example, the expression a > b is evaluated. If it evaluates to true then a is returned. If it evaluates to false, b is returned. Therefore, the line MAX(4, 12); evaluates to 12.\r\n\r\nYou can use this to pick which value to assign to a variable:\r\nint foo = (bar > bash) ? bar : bash;\r\nIn this example, either 'bar' or 'bash' is assigned to 'foo', depending on which is bigger.\r\n\r\nOr even which variable to assign a value to:\r\n((bar > bash) ? bar : bash) = foo;\r\nHere, 'foo' is assigned to 'bar' or 'bash', again depending on which is bigger.\u0000"}},"Constants/ Literals":{"Definition":{"Info":"Constants refer to fixed values that the program may not alter and they are called literals.\r\n\r\nLiterals are explicit values in a program. This can be a boolean like true, the number 3 or 4.15; but this can also be the character 'a' or the C string \"hallo\". Even den lambda function [](int a, int b){ return a+b; } is a function literal. With C++11 it's possible to generate user-defined literals by adding a suffix to a built-in literal for integers, floating points, characters, and C strings.\r\n\r\nConstants can be of any of the basic data types and can be divided into Integer Numerals, Floating-Point Numerals, Characters, Strings and Boolean Values.\r\n\r\nAgain, constants are treated just like regular variables except that their values cannot be modified after their definition.\r\n\r\nDefining Constants:\r\nThere are two simple ways in C++ to define constants \u0012\r\n1. Using #define preprocessor.\r\n2. Using const keyword.\u0000","Code":"Integer Literals  - 212\r\nFloating-point Literals - 3.14\r\nBoolean Literals  - true/ false (not 0 or 1)\r\nCharacter Literals  - \"/?\" which is the ? character\r\nString Literals - \"Hello\"\r\n\r\nhttps://www.modernescpp.com/index.php/user-defined-literals\u0000"},"User-defined Literals":{"Info":"There are six major categories of literals in C++: integer, character, floating-point, string, boolean, and pointer. Starting in C++ 11, you can define your own literals based on these categories, to provide syntactic shortcuts for common idioms and increase type safety. For example, let's say you have a Distance class. You could define a literal for kilometers and another one for miles, and encourage the user to be explicit about the units of measure by writing: auto d = 42.0_km or auto d = 42.0_mi. There's no performance advantage or disadvantage to user-defined literals; they're primarily for convenience or for compile-time type deduction. The Standard Library has user-defined literals for std::string, for std::complex, and for units in time and duration operations in the <chrono> header:\u0000","Code":"For example, let's imagine a CSS oriented code:\r\n\r\ncss::Font::Size p0 = 12_pt ;       // Ok\r\ncss::Font::Size p1 = 50_percent ;  // Ok\r\ncss::Font::Size p2 = 15_px ;       // Ok\r\ncss::Font::Size p3 = 10_em ;       // Ok\r\ncss::Font::Size p4 = 15 ;         // ERROR : Won't compile !\u0000"}},"Type":{"Definition":{"Info":"The concept of type is very important in C++. Every variable, function argument, and function return value must have a type in order to be compiled. Also, every expression (including literal values) is implicitly given a type by the compiler before it is evaluated. Some examples of types include int to store integer values, double to store floating-point values (also known as scalar data types), or the Standard Library class std::basic_string to store text. You can create your own type by defining a class or struct. \r\n\r\nThe type specifies the amount of memory that will be allocated for the variable (or expression result), the kinds of values that may be stored in that variable, how those values (as bit patterns) are interpreted, and the operations that can be performed on it. \r\n\r\nAfter you first declare a variable, you cannot change its type at some later point. However, you can copy the variable\u0019s value or a function\u0019s return value into another variable of a different type. Such operations are called type conversions, which are sometimes necessary but are also potential sources of data loss or incorrectness.\u0000","Code":"https://en.cppreference.com/w/cpp/language/type\u0000"},"Auto":{"Info":"auto keyword to instruct the compiler to deduce the type from the initializer.\u0000","Code":"\u0000"},"Fundamental (Built in) Types":{"Info":"Unlike some languages, C++ has no universal base type from which all other types are derived. The language includes many fundamental types, also known as built-in types. This includes numeric types such as int, double, long, bool, plus the char and wchar_t types for ASCII and UNICODE characters, respectively. Most integral fundamental types (except bool, double, wchar_t, and related types) all have unsigned versions, which modify the range of values that the variable can store. For example, an int, which stores a 32-bit signed integer, can represent a value from -2,147,483,648 to 2,147,483,647. An unsigned int, which is also stored as 32-bits, can store a value from 0 to 4,294,967,295. The total number of possible values in each case is the same; only the range is different.\r\n\r\nThe fundamental types are recognized by the compiler, which has built-in rules that govern what operations you can perform on them, and how they can be converted to other fundamental types. For a complete list of built-in types and their size and numeric limits, see Built-in types.\u0000","Code":"The following table lists the most frequently used fundamental types, and their sizes in the Microsoft C++ implementation:\r\n\r\nint:\r\n4 bytes  - The default choice for integral values.\r\n\r\ndouble:\r\n8 bytes - The default choice for floating point values.\r\n\r\nbool:\r\n1 byte - Represents values that can be either true or false.\r\n\r\nchar:\r\n1 byte - Use for ASCII characters in older C-style strings or std::string objects that will never have to be converted to UNICODE.\r\n\r\nwchar_t:\r\n2 bytes - Represents \"wide\" character values that may be encoded in UNICODE format (UTF-16 on Windows, other operating systems may differ). This is the character type that is used in strings of type std::wstring.\r\n\r\nunsigned char:\r\n1 byte - C++ has no built-in byte type. Use unsigned char to represent a byte value.\r\n\r\nunsigned int:\r\n4 bytes - Default choice for bit flags.\r\n\r\nlong long:\r\n8 bytes - Represents very large integer values.\u0000"},"Void":{"Info":"The void type is a special type; you cannot declare a variable of type void, but you can declare a variable of type void * (pointer to void), which is sometimes necessary when allocating raw (un-typed) memory. However, pointers to void are not type-safe and generally their use is strongly discouraged in modern C++. In a function declaration, a void return value means that the function does not return a value; this is a common and acceptable use of void. While the C language required functions that have zero parameters to declare void in the parameter list, for example, fou(void), this practice is discouraged in modern C++ and should be declared fou(). For more information, see Type Conversions and Type Safety.\u0000","Code":"\u0000"},"User-Defined Types":{"Info":"When you define a class, struct, union, or enum, that construct is used in the rest of your code as if it were a fundamental type. It has a known size in memory, and certain rules about how it can be used apply to it for compile-time checking and, at runtime, for the life of your program. The primary differences between the fundamental built-in types and user-defined types are as follows:\r\n\r\nThe compiler has no built-in knowledge of a user-defined type. It learns of the type when it first encounters the definition during the compilation process.\r\n\r\nYou specify what operations can be performed on your type, and how it can be converted to other types, by defining (through overloading) the appropriate operators, either as class members or non-member functions. For more information, see Function Overloading.\u0000","Code":"\u0000"},"Pointers":{"Info":"Dating back to the earliest versions of the C language, C++ continues to let you declare a variable of a pointer type by using the special declarator * (asterisk). A pointer type stores the address of the location in memory where the actual data value is stored. \r\n\r\nIn modern C++, these are referred to as raw pointers, and are accessed in your code through special operators * (asterisk) or -> (dash with greater-than). This is called dereferencing, and which one that you use depends on whether you are dereferencing a pointer to a scalar or a pointer to a member in an object. Working with pointer types has long been one of the most challenging and confusing aspects of C and C++ program development. This section outlines some facts and practices to help use raw pointers if you want to, but in modern C++ it\u0019s no longer required (or recommended) to use raw pointers for object ownership at all, due to the evolution of the smart pointer (discussed more at the end of this section). It is still useful and safe to use raw pointers for observing objects, but if you must use them for object ownership, you should do so with caution and very careful consideration of how the objects owned by them are created and destroyed.\r\n\r\nThe corrected code example uses local stack memory to create the backing store that pNumber points to. We use a fundamental type for simplicity. In practice, the backing store for pointers are most often user-defined types that are dynamically-allocated in an area of memory called the heap (or free store) by using a new keyword expression (in C-style programming, the older malloc() C runtime library function was used). Once allocated, these variables are usually referred to as objects, especially if they are based on a class definition. Memory that is allocated with new must be deleted by a corresponding delete statement (or, if you used the malloc() function to allocate it, the C runtime function free()).\r\n\r\nHowever, it is easy to forget to delete a dynamically-allocated object- especially in complex code, which causes a resource bug called a memory leak. For this reason, the use of raw pointers is strongly discouraged in modern C++. It is almost always better to wrap a raw pointer in a smart pointer, which will automatically release the memory when its destructor is invoked (when the code goes out of scope for the smart pointer); by using smart pointers you virtually eliminate a whole class of bugs in your C++ programs. In the following example, assume MyClass is a user-defined type that has a public method DoSomeWork();\r\n\r\nThe first thing that you should know is declaring a raw pointer variable will allocate only the memory that is required to store an address of the memory location that the pointer will be referring to when it is dereferenced. Allocation of the memory for the data value itself (also called backing store) is not yet allocated. In other words, by declaring a raw pointer variable, you are creating a memory address variable, not an actual data variable. Dereferencing a pointer variable before making sure that it contains a valid address to a backing store will cause undefined behavior (usually a fatal error) in your program. The following example demonstrates this kind of error:\u0000","Code":"    int number = 10;          // Declare and initialize a local integer\r\n                              // variable for data backing store.\r\n    int* pNumber = &number;   // Declare and initialize a local integer\r\n                              // pointer variable to a valid memory\r\n                              // address to that backing store.\r\n...\r\n    *pNumber = 41;            // Dereference and store a new value in\r\n                              // the memory pointed to by\r\n                              // pNumber, the integer variable called\r\n                              // \"number\". Note \"number\" was changed, not\r\n                              // \"pNumber\".\r\n\r\nSmart pointer:\r\nvoid someFunction() {\r\n    unique_ptr<MyClass> pMc(new MyClass);\r\n    pMc->DoSomeWork();\r\n}\r\n  // No memory leak. Out-of-scope automatically calls the destructor\r\n  // for the unique_ptr, freeing the resource.\u0000"},"Windows Data Types":{"Info":"In classic Win32 programming for C and C++, most functions use Windows-specific typedefs and #define macros (defined in windef.h) to specify the types of parameters and return values. These Windows data types are mostly just special names (aliases) given to C/C++ built-in types. For a complete list of these typedefs and preprocessor definitions, see Windows Data Types. Some of these typedefs, such as HRESULT and LCID, are useful and descriptive. Others, such as INT, have no special meaning and are just aliases for fundamental C++ types. Other Windows data types have names that are retained from the days of C programming and 16-bit processors, and have no purpose or meaning on modern hardware or operating systems. There are also special data types associated with the Windows Runtime Library, listed as Windows Runtime base data types. In modern C++, the general guideline is to prefer the C++ fundamental types unless the Windows type communicates some additional meaning about how the value is to be interpreted.","Code":""},"Reference":{"Info":"Declares a named variable as a reference, that is, an alias to an already-existing object or function.\u0000","Code":"std::string s = \"Ex\";\r\nstd::string& r1 = s;\u0000"},"Typedef":{"Info":"typedef is a reserved keyword in the programming languages C and C++. It is used to create an additional name (alias) for another data type, but does not create a new type, except in the obscure case of a qualified typedef of an array type where the typedef qualifiers are transferred to the array element type. As such, it is often used to simplify the syntax of declaring complex data structures consisting of struct and union types, but is just as common in providing specific descriptive type names for integer data types of varying lengths.","Code":"typedef int length;\r\n\r\ntypedef int km_per_hour;\r\ntypedef int points;\r\n\r\n// `km_per_hour` is synonymous with `int` here, and thus, the compiler treats\r\n// our new variables as integers.\r\nkm_per_hour current_speed;\r\npoints high_score;\r\n\r\nvoid congratulate(points your_score) {\r\n    if (your_score > high_score) {\r\n        // ...\r\n    }\r\n}"},"Implicit and Explicit Conversions":{"Info":"Implicit conversion:\r\nThis will be done automatically by the compiler in specific cases, for example:\r\nint a = 1;\r\ndouble value = a; // Here there was no need to explicitly convert or cast the int in order to make a double.\r\n\r\nTo be explicit can cast the double into an int, this is C type casting. \r\nint b = (int) value; \r\n\r\n\u0000","Code":"\u0000"},"Trailing Return Types":{"Info":"Trailing return types are addictive; they increase gestalt by lining up the function names, emphaise the function names, and are mathematicalr- like f(x) -> y.\u0000","Code":"auto search(std::filesystem::path file, std::string search_for, std::string corpus) -> std::string\u0000"}},"Common Code":{"Naming Conventions":{"Info":"Use tabs for indentation, spaces for alignment: the superior approach. Code is indented and aligned properly, and indentation is flexible. So only tab at the start of a line to the first character, never do VARIABLE <TAB> = 1; \r\n\r\nVariables - camelCase\r\nClasses - UpperCase\r\n\u0000","Code":"\u0000"},"Coding Practices":{"Info":"Write Unit Tests: \r\nCode a bit, write a test for it. Then code some more. There is no real need to TDD, but code a bit test a bit works. \r\n\r\nIf you don\u0019t have a strong opinion for using tabs, use spaces to indent. Using spaces is more simple than using tabs (less probability that someone will do it in a wrong way, check G.7). If you don\u0019t intend to indent properly with tabs, just use spaces.\r\n\r\nIf you don\u0019t have a strong opinion for using opening brace in the newline, then use a brace in the same line as the statement. This way the user can see more lines on the screen at a time.\r\n\r\nIf you don\u0019t have any strong preferences for naming, use camelCase style.\r\n\r\nIf you don\u0019t have any preferences whether there should be long lines in the source code, then consider limiting them to 100-120 characters. Yes, we use wide monitors and fullscreen editors, but several files that use margins up to 120 chars can be opened simultaneously. It\u0019s possible to have the cpp implementation file on the left, and header file on the right \u0013 2 files open at once. If you use unlimited lines, the screen will be unnecessarily cluttered. If you reach 120 chars too easily, then consider using camelCase in order to make names slightly smaller.\r\n\r\nBut, most important thing above all, is to be consistent with your style. If you have problems with it, then use automatic code formatter, like clang-format.\r\n\r\n\u0000","Code":"Current questions to ask about my code:\r\nCan I use auto? \u0000"}},"Classes":{"Definition":{"Info":"","Code":""},"Implicit and Explicit Constructors":{"Info":"Implicit is something that happens automatically, without instruction, without you explicitly telling it what to do.\r\n\r\nCompiler is allowed to perform 1 implicit conversion on code, which can be done instead of casting. \r\n\r\nWriting explicit before a constructor disables this feature, specifying that the parameter passed will not be converted when instantiating the class. \r\n\r\nImplicit conversion is used frequently by the c++ compiler between types that can easily be converted, for example > 1\r\n\r\nWhen this happens, it is possible for data to be lost in the conversion, therefore you may wish to use explicit to prevent this from happening.\u0000","Code":"Example 1: \r\n    int x = 10; // integer x\r\n    char y = 'a'; // character c\r\n  \r\n    // y implicitly converted to int. ASCII\r\n    // value of 'a' is 97\r\n    x = x + y;\r\n  \r\n    // x is implicitly converted to float\r\n    float z = x + 1.0;\r\n\r\n\r\n\r\nExample 2: \r\nclass Entity\r\n{\r\nprivate:\r\n    std::string m_Name; \r\n    int m_Age; \r\n\r\npublic: \r\n// Constructor 1\r\n    Entity(const std::string& name)\r\n        : m_Name(name), m_Age(-1){}\r\n// Constructor 2\r\n    Entity(int age)\r\n        : m_Name(\"Unknown\"), m_Age(age){}\r\n};\r\n\r\nint main{\r\n    \r\n// Normal way of instantiating objects \r\nEntity a(\"Simon\");\r\nEntity b(28); \r\n\r\n// or you can \r\nEntity a = \"Simon\"; // The conversion converts from string to an Entity\r\nEntity b = 12; // the conversion converts from an int to an Entity\r\n\r\n// here, b isn't an int, but the implicit conversion is casting from an // int to a class instantiation.\r\n\r\n// Common is to then pass this object to a function that takes in a class type as an argument, so \r\n\r\nvoid PrintEntity(const Entity& entity){// do stuff}\r\n\r\n// You could not do \r\nPrintEntity(\"Simon\") // as only 1 type conversion is permitted and it // would have to convert it here from a char array to a string then // to Entity, but you could do\r\nPrintEntity(Entity(\"Simon\"));\r\n// or \r\nPrintEntity(std::string(\"Simon\"));\r\n}\r\n\r\n// If within the class we had\r\nExplicit Entity(const std::string& name)\r\n        : m_Name(name), m_Age(-1){}\r\n// Then you could not do \r\nEntity a  = \"Simon\";\r\n// But you could do\r\n// Entity(\"Simon\"); \u0000"},"Setting Member Variables":{"Info":"The code example is called via MyClass(4) and it's private variable i will be set to 4. Cleaner than i = i. ","Code":"class MyClass {\r\npublic:\r\n    explicit MyClass(int i): i(i) {}\r\nprivate:\r\n    int i;\r\n};"},"Style":{"Info":"Should use Explicit Constructors.\u0000","Code":"class MyClass {\r\npublic:\r\n    explicit MyClass(int i): i(i) {}\r\nprivate:\r\n    int i;\r\n};\u0000"},"Access Specifiers":{"Info":"In C++, there are three access specifiers:\r\n\r\nPublic:\r\nMembers are accessible from outside the class\r\n\r\nPrivate:\r\nMembers cannot be accessed (or viewed) from outside the class\r\n\r\nProtected: \r\nMembers cannot be accessed from outside the class, however, they can be accessed in inherited classes. \u0000","Code":"\u0000"},"Constructor":{"Info":"As these are usually pretty simple,  they can be defined within header file as Classname(){}; It is optional to create a function for the constructor.\r\n\r\nConstructors are a special method which runs when an object (of a class or a struct) is instantiated. Constructors must have the same name as the class. Can't return values so no returnType needed. \r\n\r\nOverloading Constructors :\r\nConstructor overloading is a concept of having more than one constructor with different parameters list, in such a way so that each constructor performs a different task. For e.g. Vector class has 4 types of constructors.\r\n\r\nConstructor initialisation list:\r\nmoving the initialisation of the parameters of the constructor implementation. Only used for simple initialisation. e.g Person::Person(): name(\"unnamed\"), age(0) {}; Can also put initialisation list in prototype. Initialising instance variables in the initialisation list in both the prototype or method\r\n\r\nCopy constructors:\r\nInvoking copy constructor which sets the fields, example uses setting class name, making second class = to first then renaming second class. Then shows ways of invoking/ calling the copy constructor.\r\n\r\nConstructor inheritance: \r\nConstructors are not inherited in C++, you cannot call the constructor of a superclass when you construct a subclass, but C++ will always run one conductor from the superclass when you run the subclass. Need to specify in subclass which constructor is to run.","Code":""},"Destructor":{"Info":"Special method which runs when object is destroyed. Destructors begin with a tilde rather than nothing ~. Can auto create when building classes template. Can't return values so no returnType needed. Optional as a basic destructor is called anyway.\u0000","Code":"~Classname() = default;\u0000"},"Initialising":{"Info":"To initialise a class instance in int main would type \"class className;\".\r\nTo initialise multiple instances separate with comma - \"class class1Name, class2Name;\"\r\nCan also initliase pointers of type class at the same time \"class *class_ptr, class1Name; \"\u0000","Code":"\u0000"},"Methods":{"Info":"Functions within a class","Code":""},"Initialisation Lists":{"Info":"Initializer list is used to initialize data members. The syntax begins with a colon(:) and then each variable along with its value separated by a comma. The initializer list does not end in a semicolon.\r\n\r\nUse initialisation lists:\r\n1) When no Base class default constructor is present\r\n2) When reference type is used:\r\nIf you have a data member as reference type, you must initialize it in the initialization list. References are immutable hence they can be initialized only once.\r\n3) For initializing const data member:\r\nconst data members can be initialized only once, so it must be initialized in the initialization list.\r\n4) When data member and parameter have same name\r\n5) For improving performance:\r\nIf you are assigning the values inside the body of the constructor, then a temporary object would be created which will be provided to the assignment operator. The temporary object will be destroyed at the end of the assignment statement. Creation of temporary object can be avoided by using initializer list.\r\n\r\nInitialisation lists are preferred over manually saying this->x = x. Using initialization lists allows the compiler to perform additional checks related to order of field initialization. It\u0019s also possible to avoid having to use underscores to differentiate between the argument name in the constructor, and the field name. It\u0019s also possible to avoid the this specifier.\r\n\r\n\u0000","Code":"class Base{\r\nprivate:\r\n    std::string word;\r\n//Instead of this:\r\n\r\nclass Something {\r\npublic:\r\n    Something(int field) {\r\n        this->field = field;\r\n    }\r\n \r\nprivate:\r\n    int field;\r\n};\r\n\r\n//Prefer this:\r\n\r\nclass Something {\r\npublic:\r\n    Something(int field): field(field) { }\r\n \r\nprivate:\r\n    int field;\r\n};\u0000"},"Getters & Setters":{"Info":"Methods for getting and setting values within a class I.e getting and setting instance variables. Use to set the values using information which is passed in. Setter can also be called mutator. The set method part is where you define the variable. The get method part is using that new redefined/ set variable.","Code":""},"Data Members":{"Info":"Instances of a class data type are known as objects and can contain member variables, constants, member functions, and overloaded operators defined by the programmer.\r\n\r\nData members are class variables. As per google these should always be followed by an underscore https://google.github.io/styleguide/cppguide.html#Variable_Names\r\n\u001cData members of classes (but not structs) additionally have trailing underscores\u001d.\u0000","Code":"\u0000"},"Difference to Structs":{"Info":"Structs are value type whereas Classes are reference type.\r\nStructs are stored on the stack whereas Classes are stored on the heap.\r\nValue types hold their value in memory where they are declared, but reference type holds a reference to an object memory.\r\nValue types destroyed immediately after the scope is lost whereas reference type only the variable destroy after the scope is lost. The object is later destroyed by the garbage collector.\r\nWhen you copy struct into another struct, a new copy of that struct gets created modified of one struct won't affect the value of the other struct.\r\nWhen you copy a class into another class, it only copies the reference variable.\r\nBoth the reference variable point to the same object on the heap. Change to one variable will affect the other reference variable.\r\nStructs can not have destructors, but classes can have destructors.\r\nStructs can not have explicit parameterless constructors whereas classes can. Structs don't support inheritance, but classes do. Both support inheritance from an interface.\r\nStructs are sealed type.\u0000","Code":"\u0000"}},"Casting":{"Definition":{"Info":"Casting is where one type is converted into another. This can be done in 2 ways: \r\n\r\n(type)expression - Casting by assignment, the C style\r\nstatic_cast<int>(variable) - Via Cast Operator, the C++ style\r\n\r\nCasting by assignment:\r\nThis is done by explicitly defining the required type in front of the expression in parenthesis. This can be also considered as forceful casting. e.g (type) expression\r\n\r\nConversion using Cast operator: \r\nA Cast operator is an unary operator which forces one data type to be converted into another data type.\r\n\r\nThere are 4 types of casting, which is beneficial compared to c style casting as you can locate the casting in your code and reduce errors: \r\n\r\nStatic Cast\r\nDynamic Cast\r\nConst Cast\r\nReinterpret Cast\r\n\r\nFor example let's consider basic number types.\r\n\r\nWhen you convert for example int(12) to unsigned float (12.0f) your processor needs to invoke some calculations as both numbers has different bit representation. This is what static_cast stands for.\r\n\r\nOn the other hand, when you call reinterpret_cast the CPU does not invoke any calculations. It just treats a set of bits in the memory like if it had another type. So when you convert int* to float* with this keyword, the new value (after pointer dereferecing) has nothing to do with the old value in mathematical meaning.\r\n\r\n\r\n\u0000","Code":"Casting by assignment: \r\nint x = (int)y; \r\n\r\nConversion using Cast operator: \r\nint b = static_cast<int>(f);\r\n\r\nExplicit casting:\r\nTo be explicit can cast the double into an int, this is C type casting.\r\ndouble value = 5.25; \r\nint b = (int)value; \r\n\r\nC++ style casting would use static cast\r\nint b = static_cast<int>(value); \r\n\u0000"},"Static Cast":{"Info":"Static Cast:\r\nCompile time casting, used for basic type casting\r\n\r\nWhen you convert for example int(12) to unsigned float (12.0f) your processor needs to invoke some calculations as both numbers has different bit representation. This is what static_cast stands for.\r\n\r\nC++ style casting would use static cast\r\nint b = static_cast<int>(value); \r\n\r\n\u0000","Code":"int b = static_cast<int>(f);\r\n\u0000"},"Dynamic Cast":{"Info":"Dynamic Cast: \r\nRuntime casting, used for determining what ype of object somethign might be to ensure it's type safe, then if the dynamic cast is not null, then it is an object of that type.\u0000","Code":"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\u0000"},"Const Cast":{"Info":"Const Cast :\r\nUsed to change the constant value of an object or we can say it is used to remove the constant nature of an object. This is only in reference to the pointers, it cannot change an actual const variable. \r\n\r\nThe example shows the basic use of const_cast. Here we have declared a constant variable \u001dx\u001d of type int which has been assigned a value of 50 and another constant pointer \u001cy\u001d of type int which points at the variable \u001cx\u001d.\r\n\r\nA third pointer has to be created to use const_cast, and here we have created pointer \u001dz\u001d of the same data type, that is, int.\r\n\r\nSo when we pass our constant pointer \u001cy\u001d, that points at constant variable \u001cx\u001d into const_cast, and assign a value to the pointer z, we are able to make changes to the value of our constant pointer \u001cy\u001d.\r\n\r\nThis way we were able to change the constant value from 50 to 100 using const_cast.\r\n\r\nIf we try to change the value of \u001cx\u001d that the pointer \u001cy\u001d is pointing at without using const_cast , then the following error will be shown-\u001cassignment of read-only location\u001d","Code":"Input: x = 50\r\nconst int* y = &x\r\ncout<<\"old value is\"<<*y<<\"\\n\";\r\nint* z=const_cast<int *>(y);\r\n*z=100;\r\ncout<<\"new value is\"<<*y;\r\n\r\nOutput: old value is 50\r\nnew value is 100\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},"Reinterpret Cast":{"Info":"Reinterpret Cast:\r\n\r\nLet's consider basic number types.\r\n\r\nWhen you convert for example int(12) to unsigned float (12.0f) your processor needs to invoke some calculations as both numbers has different bit representation. This is what static_cast stands for.\r\n\r\nOn the other hand, when you call reinterpret_cast the CPU does not invoke any calculations. It just treats a set of bits in the memory like if it had another type. So when you convert int* to float* with this keyword, the new value (after pointer dereferecing) has nothing to do with the old value in mathematical meaning.\r\n\r\n","Code":""}},"Static":{"Static Functions":{"Info":"Prefer namespaces over classes with only static methods. \r\n\r\nGenerally it\u0019s better to use a namespace and declare simple functions inside it, than to declare a class, and put only static methods in it.\r\n\r\nThe upside of the second approach is that it\u0019s possible to write using namespace Collection and call functions from inside the namespace without prefixing them with Collection::. Also, second example uses 1 indentation level less than the first example.\u0000","Code":"class Collection {\r\npublic:\r\n    static int f1() { }\r\n    static int f2() { }\r\n    static int f3() { }\r\n};\r\n\r\n// This most preferably should be changed to:\r\n\r\nnamespace Collection {\r\n \r\nint f1() { }\r\nint f2() { }\r\nint f3() { }\r\n \r\n}\u0000"}},"Inheritance":{"Override":{"Info":"The override keyword serves two purposes:\r\n\r\nIt shows the reader of the code that \"this is a virtual method, that is overriding a virtual method of the base class.\"\r\n\r\nThe compiler also knows that it's an override, so it can \"check\" that you are not altering/adding new methods that you think are overrides.\r\n\r\nIn the example, In derived2 the compiler will issue an error for \"changing the type\". Without override, at most the compiler would give a warning for \"you are hiding virtual method by same name\".","Code":"class base\r\n{\r\n  public:\r\n    virtual int foo(float x) = 0; \r\n};\r\n\r\n\r\nclass derived: public base\r\n{\r\n   public:\r\n     int foo(float x) override { ... } // OK\r\n}\r\n\r\nclass derived2: public base\r\n{\r\n   public:\r\n     int foo(int x) override { ... } // ERROR\r\n};\r\n\r\n"},"Virtual":{"Info":"A virtual member is a member function that can be redefined in a derived class, while preserving its calling properties through references. The syntax for a function to become virtual is to precede its declaration with the virtual keyword. \r\n\r\nThis is so that when calling a function through a pointer that at run time the compiler will choose which derived function to run. Virtual functions ensure that the correct function is called for an object, regardless of the type of reference (or pointer) used for function call. It seems largely to be used so that you can use a pointer to a base class and have it call the correct derived class function, rather than the base class function which a pointer would do all the time if not virtual. Could create an overloaded function to handle the pointer but virtual is the better way.\r\n\r\nInstead of having the base class function as virtual, you could instead have it non-virtual and call a virtual function by instead saying this->function() so that the function of the derived object is called.\r\nPure virtual is where the derived classes MUST override the function with the override keyword or there will be a compile error.\u0000","Code":"\u0000"},"Definition":{"Info":"So you put all common things into a \"base class\". Then in the \"derived class\" you can access all things in base class as well as your own class.\r\n\r\nDerived classes do not inherit the constructors and destructors of the base class but when a derived class is instantiated it the base class constructor runs first as the base class needs to be initialised before the derived class gets created. Then as well once the derived class exits the derived class's destructor will automatically call the base class's destructor.\r\n","Code":""},"Final":{"Info":"Declaring a class final will prevent a derived classes. Prevents inheritance.\r\n\r\nThis is done: \r\nFor efficiency: to avoid your function calls being virtual.\r\nFor safety: to ensure that your class is not used as a base class (for example, to be sure that you can copy objects without fear of slicing).\u0000","Code":"\u0000"}},"Structs":{"Definition":{"Info":"","Code":""},"Parsing":{"Info":"If you\u0019re parsing a well-known structure, like in MachO executable format, JPEG image, or whatever, chances are that the official documentation for this format already names a field with some name. For example:\u0000","Code":"struct segment_command_64 {\r\n    uint32_t  cmd;\r\n    uint32_t  cmdsize;\r\n    char      segname[16];\r\n    uint64_t  vmaddr;\r\n    uint64_t  vmsize;\r\n    uint64_t  fileoff;\r\n    uint64_t  filesize;\r\n    vm_prot_t maxprot;\r\n    vm_prot_t initprot;\r\n    uint32_t  nsects;\r\n    uint32_t  flags;\r\n};\u0000"}},"Futures":{"Definition":{"Info":"","Code":""}},"Promises":{"Definition":{"Info":"","Code":""}}},"Data types":{"Data Type Categories":{"Abstract":{"Info":"Information","Code":"Code"},"Derived":{"Info":"","Code":""},"Primative":{"Info":"","Code":""},"User-Defined":{"Info":"","Code":""}},"Managing Data Types":{"Casting (typecasting)":{"Info":"","Code":""}},"Variables":{"Definition":{"Info":"Value that can change depending on conditions or information passed to program. \r\n\r\nExamples:\r\nint i;\r\nbool i;\r\nstd:string i; \r\nIn each example, i is the variable.\r\n\r\nRelated Terms:\r\nInstance variables - Variables which belong to a class.\r\n\r\nConst - put this before variable to prevent it from being edited later, helps prevent bugs.\r\nRelated Terms:\r\nInitialising - Means to set the value\r\nDeclaring\r\nint input = function = Means that we are returning whatever integer is the result of the function\r\n\r\n\u0000","Code":"Basic example:\r\nint i;\r\n\r\nDeclation:\r\nint i;\r\n\r\nDefinition:\r\ni = 2; or int i = 2; \u0000"},"Static":{"Info":"The Static Keyword :\r\n\r\nDeclaring a variable static within a class means that it is shared by all the objects created from that class rather than each class being able to initialise the variable individually. \r\n\r\nImagine an example of a number counter function within a class. This function can be called multiple times and will increment the static variable rather than start at 0 each time it is called. \r\n\r\nStatic objects therefore cannot be initialised within the constructor (else it would try to initialise it each time a class instance is created}.\r\n\r\nFunctions can also be static, which then allows the function to be called without initialising the class e.g Helpers::ConvertToString(int i);. \u0000","Code":"static int i; \r\n\r\n\u0000"},"Const":{"Info":"Const : \r\n\r\nPut this before variable to prevent it from being edited later, helps prevent bugs.\r\n","Code":"const int i = 2; "}},"Integer":{"Definition":{"Info":"","Code":""}},"Float":{"Definition":{"Info":"","Code":""}},"Double":{"Definition":{"Info":"","Code":""}},"Pointers":{"Smart Pointers":{"Info":"Smart pointers available since C++11 are an essential foundation for writing secure code in Modern C++. Thanks to RAII (Resource Acquisition Is Initialization), they allow you to work with pointers to allocate memory or other managed objects efficiently.\r\n\r\nThere are 3 types of smart pointers:\r\nunique\r\nshared\r\nweak\r\n\r\n- Smart pointers are located in the <memory> header.\r\n- Smart pointers are \u001csmart\u001d because they hold a pointer to an object/resource plus they know the ownership of the pointer. The are based on the RAII\r\npattern.\r\n- unique_ptr and shared_ptr have overloaded access operators * and ->, so smart pointers can be dereferenced like regular raw pointers.\r\n- Use .get() (on unique_ptr and shared_ptr) to access the raw, underlying pointer.\r\n- .get() is useful when you want to pass a pointer to a function to \u001cobserve\u001d the managed object\r\nvoid useObject(MyType* pObj) { }\r\nuseObject(mySmartPtr.get());\r\n- unique_ptr (since C++11) and shared_ptr (since C++17) have template specialization for arrays (delete[] will be called on clean up). This might be\r\nhelpful when you get a pointer to an array from some third-party library or a legacy system. Still, if possible, it\u0019s better to use some standard containers\r\nlike std::vector or std::array.\r\n- Reminder: don\u0019t use auto_ptr! It has been deprecated since C++11 and removed in C++17.Replace it with unique_ptr.\r\n- You can try with modernize-replace-auto-ptr from Clang Tidy to automate refactoring.\r\n- In C++17/C++20, there is no class template argument deduction (CTAD) for smart pointers. It is impossible for the compiler to distinguish a pointer obtained\r\nfrom an array and non-array forms of new().\r\n- Since C++20 there are atomic smart pointers std::atomic<std::shared_ptr<T>> and std::atomic<std::weak_ptr<T>>. C++20 also deprecates global atomic functions for smart pointers available since C++11.\r\n- C++20 adds various *_for_overwrite creation functions which take no constructor arguments and use default-initialization (equivalent to new T). This\r\navoids unnecessary initialization in situations where the initial value\u0000","Code":"\u0000"},"Move Semantics":{"Info":"","Code":"https://stackoverflow.com/questions/3106110/what-is-move-semantics"},"Unique_ptr":{"Info":"A lightweight smart pointer that has the unique ownership of a managed object.\r\n\r\n- Unique pointer destroys the underlying object when it goes out of scope, its reset() method is called or is assigned with a new pointer/object.\r\n- unique_ptr is movable, but not copyable.\r\n- Usually, it\u0019s the size of a single native pointer (for stateless deleters, or two pointers when a pointer for deleter is required).\r\n\r\nCreation:\r\nAdvised with auto and std::make_unique:\r\n\r\nCustom deleters:\r\nA deleter is a callable object used to delete a resource. By default it uses delete or delete[]. Type of the deleter is part of the type of the unique_ptr.\r\n- using my_ptr = unique_ptr<MyTy, DelFn>;\r\n- Deleter is not called when pointer is null\r\n- get_deleter() can return a non const reference to the deleter, so it can be used to replace it \r\n\r\nPassing to functions:\r\n- unique_ptr is movable only, so it should be passed\r\nwith std::move to explicitly express the ownership\r\ntransfer:\r\nauto pObj = make_unique<MyType>(&);\r\nfunc(std::move(pObj));\r\n// pObj is invalid after the call!\r\n\r\nOther\r\n- reset() \u0013 resets the pointer (deletes the old one)\r\n- unique_ptr is also useful in \u001cpimpl\u001d idiom\r\nimplementation\r\n- unique_ptr is usually the first candidate to return\r\nfrom factory functions. If factories gets more\r\ncomplicated (like when adding caches),\u0000","Code":"auto pObj = make_unique<MyType>(&)\r\n\r\nor with explicit new:\r\n\r\nunique_ptr<MyType> pObject(new MyType(&))\r\n\r\nbut the type occurs twice here, and you need to use\r\nraw new which is not considered a modern approach.\r\n\r\nTo delete:\r\nstruct DelFn {\r\nvoid operator()(MyTy* p) {\r\np->SpecialDelete();\r\ndelete p;\r\n}};\u0000"},"Shared_ptr":{"Info":"Multiple shared pointers can point to the same object,\r\nsharing the ownership. When the last shared pointer\r\ngoes out of scope, the managed object is deleted. This\r\ntechnique is implemented through reference counting.\r\n  shared_ptr is copyable and movable\r\n  it\u0019s usually the size of two native pointers: one for\r\nthe object and one to point at the control block.\r\n  The control block usually holds the reference\r\ncounter, weak counter, deleter and allocator.\r\nCreation\r\nAdvised method is through std::make_shared():\r\nauto pObj = make_shared<MyType>(&)\r\nmake_shared will usually allocate the control block\r\nnext to the Object, so there\u0019s better memory locality.\r\nCustom deleters\r\nA deleter is stored in a control block and can be passed\r\nduring creation (not with make_shared()). Deleter is\r\nnot part of the type and can be anything callable.\r\nvoid DelFn(MyTp* p) {\r\nif (p) p->OnDelete();\r\ndelete p;\r\n}\r\nshared_ptr<MyTp> ptr(new MyTp(), DelFn);\r\n  A deleter must cope with null pointer values. A\r\nDeleter might be called when the pointer is empty.\r\n  get_deleter() (non-member function) returns a\r\nnon const pointer to the deleter\r\nPassing to functions\r\nTo share the ownership pass a shared pointer by value.\r\nReference counter is updated atomically, so you need\r\nto be aware of the extra synchronisation cost.\r\nstd::move can be also used to transfer the\r\nownership.\r\nTo observe the object use .get().\r\nOther\r\n  The reference counter access is atomic but the\r\npointer access is not thread-safe.\r\n  Use shared_from_this() to return a shared\r\npointer to *this. The class must derive from\r\nstd::enable_shared_from_this.\r\n  Casting between pointer types can be done using\r\ndynamic_pointer_cast,\r\nstatic_pointer_cast or\r\nreinterpret_pointer_cast.\r\n  shared_ptr might create cyclic dependencies and\r\nmem leaks when two pointers point to each other.","Code":""},"Weak_ptr":{"Info":"Non-owning smart pointer that holds a \"weak\u001d\r\nreference to an object that is managed by\r\nstd::shared_ptr. It must be converted to\r\nstd::shared_ptr to access the referenced object \u0013\r\nvia the lock() method.\r\n  One example where weak pointers are useful is\r\ncaching. Such system distributes only weak pointers,\r\nand before any use, the client is responsible for\r\nchecking if the resource is still alive.\r\n  A weak pointer is also used to break cycles in shared\r\npointers.\r\nCreation\r\nA weak pointer is created from a shared_ptr, but\r\nbefore using it, you have to convert it to shared_ptr\r\nagain.\r\nweak_ptr pWeak = pSharedPtr;\r\nif (auto observe = pWeak.lock()) {\r\n// the object is alive\r\n} else {\r\n// shared_ptr was deleted\r\n}\r\n  A weak pointer created from a shared pointer will\r\nincrease \u0018weak reference counter\u0019 that is stored in\r\nthe control block of the shared pointer. Even if all\r\nshared pointers (referring to a single object) are\r\ndead, but one weak pointer has a weak reference (to\r\nthat object) the control block might still be present in\r\nthe memory. This might be a problem when the\r\ncontrol block is allocated together with the object\r\n(like when using make_shared). In that case, the\r\ndestructor of the object is called, but memory is not\r\nreleased.\r\nOther\r\n  use_count() \u0013 returns the number of shared\r\npointers sharing the same managed object.\r\n  Use expired() to check if the managed object is\r\nstill present.\r\n  The weak pointer doesn\u0019t have * and -> operators\r\noverloaded, so you cannot dereference underlying\r\npointer before converting to shared_ptr (via\r\nlock()).","Code":""}},"Reference":{"Definition":{"Info":"","Code":""}},"Union":{"Definition":{"Info":"The purpose of union is to save memory by using the same memory region for storing different objects at different times. That's it.\r\n\r\nA union is a user-defined type in which all members share the same memory location. This definition means that at any given time, a union can contain no more than one object from its list of members. It also means that no matter how many members a union has, it always uses only enough memory to store the largest member.\r\n\r\nA union can be useful for conserving memory when you have lots of objects and limited memory. However, a union requires extra care to use correctly. You're responsible for ensuring that you always access the same member you assigned. If any member types have a non-trivial constructor, then you must write additional code to explicitly construct and destroy that member. Before you use a union, consider whether the problem you're trying to solve could be better expressed by using a base class and derived class types.","Code":"union RecordType    // Declare a simple union type\r\n{ char   ch;\r\n    int    i;\r\n    long   l;\r\n    float  f;};\r\n\r\nint main(){\r\n    RecordType t;\r\n    t.i = 5; // t holds an int\r\n    t.f = 7.25; // t now holds a float}"}},"Enum":{"Definition":{"Info":"Enums are used only when we expect the variable to have one of the possible set of values, for example, we have a dir variable that holds the direction. Since we have four directions, this variable can take any one of the four values, if we try to assign a another random value to this variable, it will throw a compilation error. This increases compile-time checking and avoid errors that occurs by passing in invalid constants.\r\n","Code":"enum direction {East=11, West=22, North=33, South=44};\r\nint main(){\r\n   direction dir;\r\n   dir = South;\r\n   cout<<dir; \r\n   return 0;\r\n}\r\nOutput: 44"},"Scoped Enum":{"Info":"Scoped enum is where the enum is given a class or other in order that the scope be defined.\r\n\r\n","Code":"enum direction {East=11, West=22, North=33, South=44};\r\nint main(){\r\n   direction dir;\r\n   dir = South;\r\n   cout<<dir; \r\n   return 0;\r\n}\r\nOutput: 44"},"Naming Enums":{"Info":"google.github.io/styleguide/cppguide.html#Enumerator_Names\r\n\r\nEnumerators (for both scoped and unscoped enums) should be named like constants, not like macros. That is, use kEnumName not ENUM_NAME.\u0000","Code":"\u0000"}}},"GIT":{"GIT":{"Definition":{"Info":"","Code":""}}},"Functions":{"Functions":{"Definition":{"Info":"","Code":""},"Style":{"Info":"\r\nShould do one thing: \r\nA function should be small enough to do 1 thing only. If the function does more than 1 thing, it probably should be split into smaller functions.\r\n\r\nKeep in mind that the \u001c1 thing\u001d constraint refers to the business logic; it\u0019s okay to perform argument checking first, then doing business logic, then cleaning up resources, all in one function.\r\n\r\nIt\u0019s not a hard requirement, but a really strong suggestion. It pairs with O.3 pretty well. By splitting a bigger function into smaller ones, you are simply binding a name to some code blocks, which helps readability (but you have to use sane names, so check the guidelines in the N group as well).\r\n\r\n\r\nPrefer small functions over big functions:\r\n\u0000","Code":"\u0000"}},"Loops":{"Definition":{"Info":"","Code":""}},"Recursion":{"Definition":{"Info":"Recursion: \r\n\r\nA function which calls itself.\r\n\r\nA big difference between recursion and iteration is the way that they end. While a loop executes the block of code, checking each time to see if it is at the end of the sequence, there is no such sequential end for recursive code.\r\n\r\nA recursive function consists of two parts: \r\n- the recursive call and \r\n- the base case. \r\n\r\nThe base case (or base cases sometimes) is the condition that checks to see if we have gotten the information that we need out of our function. Every recursive function should have at least one base case, though there may be multiple. We typically call the function again in the return statement.\r\n\r\nStacks are LIFO (Last In First Out) objects, meaning that the last item that was added to the top of the stack is the first one to be removed from the stack later on.\u0000","Code":"\u0000"}},"Coroutines":{"Definition":{"Info":"A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. This allows for sequential code that executes asynchronously (e.g. to handle non-blocking I/O without explicit callbacks), and also supports algorithms on lazy-computed infinite sequences and other uses.\u0000","Code":"\u0000"}},"Lambda":{"Definition":{"Info":"In C++11 and later, a lambda expression\u0014often called a lambda\u0014is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions. This article defines what lambdas are, and compares them to other programming techniques. It describes their advantages, and provides some basic examples.","Code":"void abssort(float* x, unsigned n) {\r\n    std::sort(x, x + n,\r\n        // Lambda expression begins\r\n        [](float a, float b) {\r\n            return (std::abs(a) < std::abs(b));\r\n        } // end of lambda expression\r\n    );\r\n}"}},"Asynchronous Function":{"Definition":{"Info":"","Code":""}}},"Memory":{"Computer Memory":{"Definition":{"Info":"Made up of bits. byte = 8 bits. Limit of what number you can represent in a byte, limit and max values of what can be allocated into memory","Code":""},"Bits and Bytes":{"Info":"Bit:\r\na \"bit\" is atomic, the smallest unit of storage. \r\nA bit stores just a 0 or 1\r\nAnything with two separate states can store 1 bit\r\nIn a chip: electric charge = 0/1\r\nIn a hard drive: spots of North/South magnetism = 0/1\r\nGroup 8 bits together to make 1 byte\r\n\r\nByte:\r\nOne byte = collection of 8 bits\r\ne.g. 0 1 0 1 1 0 1 0\r\nOne byte can store one character, e.g. 'A' or 'x' or '$'\u0000","Code":"\u0000"}},"Caching":{"Definition":{"Info":"In computing, a cache is a high-speed data storage layer which stores a subset of data, typically transient in nature, so that future requests for that data are served up faster than is possible by accessing the data\u0019s primary storage location. Caching allows you to efficiently reuse previously retrieved or computed data.\r\n\r\nAPI caching is common particularly when data does not need to be updated form the API frequently, for example for EOD data which is only updated once per day.\u0000","Code":"\u0000"}},"Stack and Heap Allocation":{"Definition":{"Info":"Prefer stack allocation over heap allocation:\r\nStack allocation is superior to heap allocation because it can\u0019t lead to memory leaks and is also much faster to perform, since allocating memory on a stack is a matter of adjusting just one pointer.\r\n\r\nAllocation on the heap runs a whole memory allocation algorithm, long running processes may suffer from memory fragmentation problems, you need to remember about memory ownership, you need to manage when to free the memory, etc. Those issues don\u0019t exist when using memory allocated on a stack.\r\n\r\nJust remember to keep the size sane.\r\n\r\nKey Differences: \r\nStack is a linear data structure whereas Heap is a hierarchical data structure.\r\nStack memory will never become fragmented ( phenomenon in which storage space is used inefficiently, reducing capacity or performance and often both.) whereas Heap memory can become fragmented as blocks of memory are first allocated and then freed.\r\nStack accesses local variables only while Heap allows you to access variables globally.\r\nStack variables can\u0019t be resized whereas Heap variables can be resized.\r\nStack memory is allocated in a contiguous block whereas Heap memory is allocated in any random order.\r\nStack doesn\u0019t require to de-allocate variables whereas in Heap de-allocation is needed.\r\nStack allocation and deallocation are done by compiler instructions whereas Heap allocation and deallocation is done by the programmer.\r\nStack has high speed access whereas heap is slower.\r\nImplementation - stack can be implemented in 3 ways, simple array based, using dynamic memory and linked list based. Heap can be implemented using array and trees. \u0000","Code":"\u0000"},"Stack":{"Info":"A stack is a special area of computer's memory which stores temporary variables created by a function. In stack, variables are declared, stored and initialized during runtime.\r\n\r\nIt is a temporary storage memory. When the computing task is complete, the memory of the variable will be automatically erased. The stack section mostly contains methods, local variable, and reference variables.\r\n\r\nHelps you to manage the data in a Last In First Out(LIFO) method which is not possible with Linked list and array.\r\nWhen a function is called the local variables are stored in a stack, and it is automatically destroyed once returned.\r\nA stack is used when a variable is not used outside that function.\r\nIt allows you to control how memory is allocated and deallocated.\r\nStack automatically cleans up the object.\r\nNot easily corrupted\r\nVariables cannot be resized.","Code":""},"Heap":{"Info":"The heap is a memory used by programming languages to store global variables. By default, all global variable are stored in heap memory space. It supports Dynamic memory allocation.\r\n\r\nThe heap is not managed automatically for you and is not as tightly managed by the CPU as a stack. It is more like a free-floating region of memory.\r\n\r\nHeap memory is allocated using the new keyword followed by the type of object to allocate. \r\n\r\nHeap helps you to find the greatest and minimum number\r\nGarbage collection runs on the heap memory to free the memory used by the object.\r\nHeap method also used in the Priority Queue.\r\nIt allows you to access variables globally.\r\nHeap doesn't have any limit on memory size.\u0000","Code":"double* thisDouble = new double; \r\ndelete thisDouble;\u0000"}},"RAII":{"Definition":{"Info":"Resource Acquisition is Initialization (RAII):\r\n\r\nIt's a really terrible name for an incredibly powerful concept, and perhaps one of the number 1 things that C++ developers miss when they switch to other languages. There has been a bit of a movement to try to rename this concept as Scope-Bound Resource Management, though it doesn't seem to have caught on just yet.\r\n\r\nWhen we say 'Resource' we don't just mean memory - it could be file handles, network sockets, database handles, GDI objects... In short, things that we have a finite supply of and so we need to be able to control their usage. The 'Scope-bound' aspect means that the lifetime of the object is bound to the scope of a variable, so when the variable goes out of scope then the destructor will release the resource. A very useful property of this is that it makes for greater exception-safety. \u0000","Code":"For instance, compare this:\r\n\r\nRawResourceHandle* handle=createNewResource();\r\nhandle->performInvalidOperation();  // Oops, throws exception\r\ndeleteResource(handle); // oh dear, never gets called so the resource leaks\r\n\r\nWith the RAII one:\r\n\r\nclass ManagedResourceHandle {\r\npublic:\r\n   ManagedResourceHandle(RawResourceHandle* rawHandle_) : rawHandle(rawHandle_) {};\r\n   ~ManagedResourceHandle() {delete rawHandle; }\r\n   ... // omitted operator*, etc\r\nprivate:\r\n   RawResourceHandle* rawHandle;\r\n};\r\n\r\nManagedResourceHandle handle(createNewResource());\r\nhandle->performInvalidOperation();\r\n\r\nIn this latter case, when the exception is thrown and the stack is unwound, the local variables are destroyed which ensures that our resource is cleaned up and doesn't leak.\u0000"}}},"Debugging":{"Breakpoints":{"Definition":{"Info":"","Code":""}}},"Error Handling":{"Exception Handling":{"Definition":{"Info":"https://www.cplusplus.com/doc/tutorial/exceptions/\r\n\r\n[18/08 09:50] Jamie Gordon\r\nAs an aside ... exceptions have been badly taught in the past. A lot of developers (I think even Raymond Chen) have said exceptions should not be used for general error handling. But I think mostly it's because it's harder to do it correctly. But it is faster and it is must more elegant. I mean that normal error handling. Because then you might need 50 nested if else statements in a single function. Or you need to pass errors back down a chain of 10 or 15 functions to the callee.\r\n\u000b[18/08 09:50] Jamie Gordon\r\n    Exceptions solve a lot of problems. But they can also make your program explode if you don't use them correctly\r\n\u000b[18/08 09:52] Jamie Gordon\r\n    https://devblogs.microsoft.com/oldnewthing/20060927-07/?p=29563\r\nIsBadXxxPtr should really be called CrashProgramRandomlyOften I\u0019ll see code that tries to \u001cprotect\u001d against invalid pointer parameters. This is usually done by calling a function like IsBadWritePtr. But this is a bad idea. IsBadWritePtr should really be...devblogs.microsoft.com\r\n\r\nI think maybe this is a bad general example. A lot of the times people tend to do try { } catch ( ... ) {} and that catches everything. Even things they don't expect. So if you are using it to catch an error from your function, well you just caught everything and didn't even look to see what it was. Maybe it was your exception. Maybe it was someone else's, maybe it was even needed for memory management to grow the stack pages. So by killing the exception here, and preventing it getting passed up to the person that needed it, you will cause random errors down the line","Code":""}}},"Software":{"Visual Studio Code":{"Set up":{"Info":"Download Visual Studio Code\r\n\r\nThen open up the folder.\r\n\r\nTo run a JS project, download the Code Runner Extension and then press the shortcut ctrl + alt + n to run.","Code":""}}},"Javascript":{"Basics":{"Running a file":{"Info":"With node.js installed, from the cmd you can cd to the folder to run, then enter \"node filename.js\"","Code":""}},"Node.js":{"Running a server":{"Info":"With node.js installed, from the cmd you can cd to the folder to run, then enter \"node filename.js\" if the code on the right is used and express is installed.\r\n\r\nWhen you update the code within the file, you would need to stop the server (with ctrl+c) and then restart it, however, if you download nodemon and start the server with \"nodemon filename.js\" then it will automatically update. \r\n\r\n\u0000","Code":"const express = require('express'); \r\nconst app = express();\r\n\r\n// arg 1 is path or url / represents root of website, arg 2 is callback function when get request is received at endpoint\r\napp.get('/', (req, res) => {\r\n    res.send('Hello World');\r\n}); \r\n\r\n\r\napp.get('/api/courses', (req, res) => {\r\n    res.send([1, 2, 3]);\r\n}); \r\n\r\napp.listen(3000, ()=> console.log('Listening on port 3000...')); \u0000"},"Definition":{"Info":"A runtime environment for executing JavaScript code. This would be as opposed to using a browser to run the code.\r\n\r\nOften used to build backend services, such as API's (Applicaiton Programming Interface)\u0000","Code":"\u0000"}},"Asynchronous Functions":{"Definition":{"Info":"An async function is a function that implicitly returns a promise and that can, in its body, await other promises in a way that looks synchronous. An async function is marked by the word async before the function keyword. Methods can also be made async by writing async before their name.\u0000","Code":"\u0000"}},"Stack":{"Definition":{"Info":"Java Virtual Machine translates the code into machine readable code\u0000","Code":"\u0000"}},"API":{"Rest API":{"Info":"RESTful Services or REST API:\r\n\r\nMost modern apps follow the same architecture of :\r\n - Client - The app or front end part\r\n - Server - The backend to get or save the data. \r\n\r\nThis communication happens via HTTP protocol. Server exposes services to be accessible via http and then client can send http request to the services.\r\n\r\nRepresentational State Transfer - Convention for building these services. Provides support to Create, Read, Update and Delete data. These operations are referred to as CRUD operations. \r\n\r\nExpress.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.\r\n\r\nThe server allows a resource to be accessed via HTTP, for example at http:://verify.com/api/customers. Here customers is the resource and the address is where the client can send HTTP requests to access the customers resource. \r\n\r\nHTTP Methods:\r\nGet - For retrieving data\r\nPost - For setting data\r\nPut - For updating data\r\nDelete - For deleting data\r\n\r\nThe route parameters are the e.g api/posts/2018/1. These are the required values. These are accessed through req.params.id etc...\r\nThere can also be query string parameters to define how the data should be returned, which are entered after a ?. e.g api/posts/2018/1?sortBy=name. These are accessed through req.query. The parameters are stored within a json object with key value pairs. \r\n\r\nHandling GET requests:\r\nImplement endpoint to get a new course from the server:\r\n\r\nHandling invalid GET requests:\r\n\r\nHandling POST requests:\r\nTo make the post requests, we must use chrome postman. Enter the address, then select text as json, and write a json object to send\r\n\r\nInput validation on POST requests:\r\nUsually would want far more complex validation, for this can use node package called joi. Then need to load the module with - \"const Joi = require('joi'); //\". What is returned is a class and use pascal naming convention to name classes. Put all require classes on top of the file. \r\n\r\nFirst define a schema, these define the properties of the objects. The schema is defined using the joi class, which is quite intuitive. e.g \r\nconst schema = {\r\n        name: Joi.string().min(3).required() // tells joi 'name' is a string, with min 3 characters and is required\r\n    };\r\n\r\nThen pass to joi the entered object and the schema- const result = Joi.validate(req.body, schema);\r\nThen send the result - res.status(400).send(result.error.details[0].message);\r\n\r\nHandling PUT requests:\r\nJust need to look up course, check it exists, validate request, then - course.name = req.body.name; \r\n\r\nHandling DELETE requests:\r\n\r\n","Code":"const Joi = require('joi'); //\r\nconst express = require('express'); \r\nconst { application } = require('express');\r\nconst app = express();\r\nconst courses = [ \r\n    {id:1, name:'course1'}, \r\n    {id:2, name:'course2'}, \r\n    {id:3, name:'course3'} \r\n]; \r\n\r\napp.use(express.json()); // For parsing json in object requests\r\n\r\n// arg 1 is path or url / represents root of website, arg 2 is callback function when get request is received at endpoint\r\napp.get('/', (req, res) => {\r\n    res.send('Hello World!!!');\r\n}); \r\n\r\napp.get('/api/courses', (req, res) => {\r\n    res.send(courses); // returns the courses array\r\n}); \r\n\r\n// Create an endpoint to get data from the server\r\n// http://localhost:3000/api/courses/1\r\napp.get('/api/courses/:id', (req, res) => {\r\n    // res.send(req.params.id); // Would just return the id entered in the api request\r\n    const course = courses.find(c => c.id === parseInt(req.params.id)); // First argument of find here is a function which returns true or false.\r\n    \r\n    if(!course) res.status(404).send('The course with the given ID was not found'); // return 404 meaning object not found, one of the conventions of restful apis\r\n    res.send(course); \r\n}); \r\n\r\n// http://localhost:3000/api/posts/2018/1?sortBy=name\r\napp.get('/api/posts/:year/:month', (req, res) => {\r\n    //res.send(req.params);\r\n    res.send(req.query); // this just returns the query parameters e.g sortBy:name\r\n}); \r\n\r\n// Handling a post request. Use postman to test this. \r\napp.post('/api/courses', (req, res)=> {\r\n    \r\n    const { error } = validateCourse(req.body); // this is object destructuring, so that below instead of calling result.error, we can just call error\r\n\r\n    // if invalid return 400 for bad request\r\n    if (error){\r\n        res.status(400).send(error.details[0].message);\r\n        return; \r\n    }; \r\n\r\n    const course = {\r\n        id: courses.length + 1, // Assign the entry, usually this would be assigned automatically by the database\r\n        name: req.body.name // need to enable parsing of json objects in body of the request as this is not auto enabled in Express, so above call app.use(express.json()); \r\n    };\r\n    courses.push(course); // push into array\r\n    res.send(course); // By convention, return the course object after a post, so that they know the assigned id\r\n\r\n});\r\n\r\napp.put('/api/courses/:id', (req, res) => {\r\n    // Look up the course\r\n    const course = courses.find(c => c.id === parseInt(req.params.id)); // First argument of find here is a function which returns true or false.\r\n    // If it doesn't exist return 404\r\n    if(!course) return res.status(404).send('The course with the given ID was not found');\r\n    \r\n    // otherwise validate\r\n    //const result = validateCourse(req.body); \r\n    const { error } = validateCourse(req.body); // this is object destructuring, so that below instead of calling result.error, we can just call error\r\n\r\n    // if invalid return 400 for bad request\r\n    if (error){\r\n        res.status(400).send(error.details[0].message);\r\n        return; \r\n    }; \r\n\r\n    // Update course\r\n    course.name = req.body.name; \r\n    // Return updated course\r\n    res.send(course); \r\n})\r\n\r\napp.delete('/api/courses/:id', (req, res)=>{\r\n    // Look up the course\r\n   const course = courses.find(c => c.id === parseInt(req.params.id)); // First argument of find here is a function which returns true or false.\r\n    // If it doesn't exist return 404\r\n    if(!course) return res.status(404).send('The course with the given ID was not found');\r\n\r\n    // Delete\r\n    const index = courses.indexOf(course); // Get index of course \r\n    courses.splice(index, 1); // Use splice to delete\r\n\r\n    // Return the same course\r\n    res.send(course); \r\n}); \r\n\r\n// Put the validation logic into a function to not duplicate code\r\nfunction validateCourse(course)\r\n{\r\n    const schema = {\r\n        name: Joi.string().min(3).required() // tells joi 'name' is a string, with min 3 characters and is required\r\n    };\r\n\r\n    return Joi.validate(course, schema);\r\n};\r\n\r\n// Port\r\nconst port = process.env.PORT || 3000; \r\napp.listen(port, ()=> console.log(`Listening on port ${port}...`)); "}}},"Infrastructure":{"API":{"Definition":{"Info":"API: \r\n\r\nApplication Programming Interface","Code":"Code"}},"Modules":{"Definition":{"Info":"A module is a software component or part of a program that contains one or more routines. ... Modules make a programmer's job easy by allowing the programmer to focus on only one area of the functionality of the software application. Modules are typically incorporated into the program (software) through interfaces.","Code":""}}},"Computers":{"TPM":{"Definition":{"Info":"Trusted Platform Module:\r\nTo make computers more secure. When we encrypt the pc, we need somewhere that we can store the key that isnt on the harddrive. Apple do the same thing with a secure enclave, intel have trusted execution, amd have psp. \r\n\r\nWe therefore use the TPM which is built into the motherboard. This is then accessible. Provides a way of storing keys in a way that means that someone attempting to access cannot. \r\n\r\nTMP is a little chip, small computer, can store keys, generate numbers, provides support to do cryptographic functions in a secure way. Can encrypt/ decrypt keys or can encrypt/ decrypt data depending on type. \r\n\r\nStorage Root Key:\r\nKey thats been programmed in there when chip was built that is used to encrypt the keys that we want to store. You cannot get this key out. So we can take another key, ask the TPM to encrypt it with it's storage root key. So then we can either store on the harddisk or on the TPM itself. \r\n\r\nSealing a Key:\r\nThe TPM also has a platform configuration registers to have the same state as the key. So you can only decrypt when using the same TPM and have the system in the same state. You can give the TPM this state. So you can guarentee that it's the same system and that it's the same hardware/ setup. This way it can be stored but cannot be accessed any other way.\u0000","Code":"https://www.youtube.com/watch?v=RW2zHvVO09g&ab_channel=Computerphile\u0000"}},"Encoding":{"Definition":{"Info":"","Code":""},"Character Encoding":{"Info":"In computing, data storage, and data transmission, character encoding is used to represent a repertoire of characters by some kind of encoding system that assigns a number to each character for digital representation.[1] Depending on the abstraction level and context, corresponding code points and the resulting code space may be regarded as bit patterns, octets, natural numbers, electrical pulses, or anything of the like. A character encoding is used in computation, data storage, and transmission of textual data. \"Character set\", \"character map\", \"codeset\" and \"code page\" are related, but not identical, terms.\r\n\r\nEarly character codes associated with the optical or electrical telegraph could only represent a subset of the characters used in written languages, sometimes restricted to upper case letters, numerals and some punctuation only. The low cost of digital representation of data in modern computer systems allows more elaborate character codes (such as Unicode) which represent most of the characters used in many written languages. Character encoding using internationally accepted standards permits worldwide interchange of text in electronic form.\r\n\r\nA code unit is a bit sequence used to encode each character of a repertoire within a given encoding form. This is referred to as a code value in some documents.\u0000","Code":"A code unit in US-ASCII consists of 7 bits;\r\nA code unit in UTF-8, EBCDIC and GB18030 consists of 8 bits;\r\nA code unit in UTF-16 consists of 16 bits;\r\nA code unit in UTF-32 consists of 32 bits.\u0000"},"Unicode":{"Info":"Unicode and its parallel standard, the ISO/IEC 10646 Universal Character Set, together constitute a modern, unified character encoding. Rather than mapping characters directly to octets (bytes), they separately define what characters are available, corresponding natural numbers (code points), how those numbers are encoded as a series of fixed-size natural numbers (code units), and finally how those units are encoded as a stream of octets. The purpose of this decomposition is to establish a universal set of characters that can be encoded in a variety of ways.[8] To describe this model correctly requires more precise terms than \"character set\" and \"character encoding.\" The terms used in the modern model follow. \r\n\r\nUTF-8 is the most commonly used encoding scheme used on today's computer systems and computer networks.\r\n\r\nUnicode text can be encoded in various formats: The two most important ones are UTF-8 and UTF-16. In C++ Windows code there's often a need to convert between UTF-8 and UTF-16, because Unicode-enabled Win32 APIs use UTF-16 as their native Unicode encoding.\u0000","Code":"The code unit size is equivalent to the bit measurement for the particular encoding:\r\n\r\nA code unit in US-ASCII consists of 7 bits;\r\nA code unit in UTF-8, EBCDIC and GB18030 consists of 8 bits;\r\nA code unit in UTF-16 consists of 16 bits;\r\nA code unit in UTF-32 consists of 32 bits.\r\nExample of a code unit: Consider a string of the letters \"abc\" followed by U+10400 \u0001\u0000"},"ASCI":{"Info":"ASCII (/  ski / (About this soundlisten) ASS-kee),[3]:\n6\n abbreviated from American Standard Code for Information Interchange, is a character encoding standard for electronic communication. ASCII codes represent text in computers, telecommunications equipment, and other devices. Most modern character-encoding schemes are based on ASCII, although they support many additional characters.\r\n\r\nThe Internet Assigned Numbers Authority (IANA) prefers the name US-ASCII for this character encoding.[2]\u0000","Code":"\u0000"}},"Compiler":{"Definition":{"Info":"The compliler translates the Source Code into Machine Code. \r\n\r\nThis Machine Code is also called binary, or the executable.\r\n\r\nCompilers are only required in Compiled Languages, such as C#, C++, Java etc... and not for Interpreted Languages, such as Javascript, HTML, Python.\r\n\r\nCompiled Languages interprets the line by line source code at compile time, whereas for Interpreted Languages the line by line interpretation is all done at runtime. This is why bugs in Interpreted Languages can only really be discovered when the code is run.\u0000","Code":"\u0000"}}},"Work":{"General Process":{"Starting a New Project":{"Info":"","Code":""},"Pull Request":{"Info":"Don't submit unrelated changes.\r\n\r\nUse git show to view what you are pushing\r\n\r\nEnsure the code is all ready to be pushed to master. This is your responsibility and you know it best. It is not the reviewers job to fix. ","Code":""},"Commit Messages":{"Info":"Focus on why are you making the change, not what are you changing\r\n\r\nIt\u0019s all about the context. Do yourself a favor and run git log to see your own past commits. Can you remember those changes you\u0019re looking at? If not, then you should write better commit messages.\r\n\r\nDon\u0019t treat commits as a simple Ctrl+S key, used only to save your file and nothing more. Commits pair your changes with a message for others as well as for you that describe the change you make. Commits are a tool that is helping other people to acquire your context of the change before looking at your commit\u0019s diff.\r\n\r\nThe \u001cwhat has been changed\u001d question can be answered by git directly by autogenerating the list of changed files and directories, thus if your commit description only consists of information what has been changed, it could just as well be empty.\r\n\r\n\u0000","Code":"Instead, specify why you\u0019re making the change:\r\n\r\n\"Removed a compilation warning by adding a cast\r\n \r\nJIRA-123\"\r\n\r\nor \r\n\r\nComponent: One sentence description of current change\r\n \r\n-- [ Short description of the problem causing the need for the commit ] --\r\n \r\n-- [ How the commit fixes the problem described above? ] --\r\n \r\n-- [ List of Jira tasks related to the issue ] --\r\n\r\nor \r\n\r\nImports: Changed APP_ROOT_LIST_PROCESSES prototype\r\n \r\nThe previous API allowed only to send process paths in UTF-16.\r\nThis resulted in the inability to properly process paths that\r\ncouldn't be converted to UTF-16. Linux allows such paths to\r\nexist, so the interface needed to be changed. Additionally, the\r\nUTF-16 conversion functions inside Shareds can silently drop\r\nsome invalid characters, which renders the UTF-16 string\r\nincomplete, thus invalid.\r\n \r\nInstead of using UTF-16 paths alone, the `fid` and `vid` fields\r\nwere added to `RootProcessListEntry` structure. Fid and Vid\r\nidentify the ID of the file (inode), and the ID of the volume\r\nthis file exists on.\r\n \r\nSince CleanerX receives the `fid` and `vid` of the file that needs\r\nto be removed from the engine, we can use the new fields in order\r\nto locate the target file in the process list without inspecting\r\nthe UTF-16 paths. This allows locating files that contain invalid\r\nUTF characters in their names.\r\n \r\nJIRA-XYZ\u0000"}}},"Application Development":{"Win32":{"Definition":{"Info":"Information","Code":"Code"}},"Licencing":{"Definition":{"Info":"Information","Code":"Code"},"MIT Licence":{"Info":"The MIT License Variations is a permissive free software license originating at the Massachusetts Institute of Technology (MIT)[7] in the late 1980s.[8] As a permissive license, it puts only very limited restriction on reuse and has, therefore, high license compatibility.[9][10] The Wikipedia and Wikimedia Commons projects use the alternative name Expat License\u0000","Code":"Code\u0000"}}},"Math":{"Operand":{"Definition":{"Info":"The quantity on which an operation is done.\r\n\r\nAn operand is also referred to as \"one of the inputs (quantities) for an operation\".\r\n\r\nIn the example, the operand '3' is one of the inputs (quantities) followed by the addition operator, and the operand '6' is the other input necessary for the operation.\r\n\r\nThe result of the operation is 9. (The number '9' is also called the sum of the augend 3 and the addend 6.)\r\n\r\n\u0000","Code":"3+6=9\r\n\u0000"}}},"Encryption":{"Cryptography":{"Definition":{"Info":"","Code":""},"FIPS":{"Info":"The Federal Information Processing Standard Publication 140-3, (FIPS PUB 140-3),[1][2] is a U.S. government computer security standard used to approve cryptographic modules. The title is Security Requirements for Cryptographic Modules. Initial publication was on March 22, 2019 and it supersedes FIPS 140-2.\u0000","Code":"\u0000"}}},"Windows":{".Net Framework":{"Definition":{"Info":"Library of code and system of compiling using a common intermediate language to compile to before compiling to the specific machines code.\r\n\r\nPrimary language .NET applications are written in is C#, but there are around 20 that it can support. \r\n\r\nThe .NET framework is a stack of development code for each type of development, whether web application, desktop application, cloud service, mobile app, ai. This stack goes from source code, to CIL, to CLR to Machine Code.\r\n\r\n.NET is not a language, the .NET framework consists of runtime engine and libraries for executing programs written in a compliant language.\u0000","Code":"Code\u0000"},"Stack":{"Info":"The .Net Stack is made up of:\r\nDesktop Applications - Winform, UWP\r\nWeb - ASP.NET\r\nCloud - Azure\r\nMobile - Xamarin\r\nGaming - Unity\r\nloT (Internet of Things)- ARM32, ARM64 \r\nAI - ML.NET (Machine Learning), NET for Apache Spark\r\n\r\nThese are all written in C#. \r\n\r\nThe stack appears like this:\r\nVisual Basic | C++ | C# | JS | ...+20 ish\r\nCommon Language Specification\r\nWeb Services | Web Forms | Windows Forms\r\nData and XML Classes\r\nFramework Class Library\r\nCommon Language Runtime (CLR) \u0000","Code":"\u0000"},"CLR":{"Info":"Common Language Runtime\r\n\r\nThis appears at the bottom of the .NET stack and is the second in the 2 stage process undertaken by the compiler, it translates all of the languages above it into machine readable code by accepting CIL code as input. So if you were on a Linux, the source code would be compiled into CIL code and passed to the CLR, which would compile it into code readable by the Linux machine.\r\n\r\nThe recompilation is done 'Just in time'. \r\n\r\n\u0000","Code":"\u0000"},"FCL":{"Info":"Framework Class Library\r\n\r\nIncludes code for all major areas of application development\u0000","Code":"Imports System.Text\r\nImports System.IO\u0000"},"CIL":{"Info":"Common Intermediate Language (BYTE code)\r\n\r\nWhen the source code is compiled, it is first compiled into an intermediate step before assembly code called CIL, which can be interpreted by any device which has .NET installed.\r\n\r\nThe CLR accepts the CIL as input and recompiles it into machine code. \r\n\r\nThe CIL code looks a lot like assembly code.  \r\n\r\nC# -> Compiler + CIL(+metadata) -> Loader, Verifier, JIT Compiler -> Machine Code\u0000","Code":"c#:\r\nif(a>b) max = a; else max =b\r\n\r\nCIL:\r\nIL_0004:Idloc.0\r\nIL_0005:Idloc.0\r\nIL_0006:BLE.S il_00c\r\n\r\nIntel assembly language code:\r\nmov ebx, [-4]\r\nmov edx, [-8]\r\ncmp ebx, edx\r\njle 17\r\nmov ebx, [-2] \u0000"}},"ASP.Net":{"Definition":{"Info":"Web Develpment Stack.\r\n\r\n\u0000","Code":"Code\u0000"}}},"Projects":{"EEES Update":{"Brief":{"Info":"Updating the Eset Enterprise Server Proxy:\r\n\r\nNew cloud ideas - like the idea that it can be written in node.js and also can support a REST api.\r\n\r\nI need to understand the Javascript and Node.JS technology more by:\r\n- Watching the video\r\n- Recreating the sample that he does in the video\r\n\r\nhttps://www.youtube.com/watch?v=pKd0Rpw7O48\r\n\r\nYou will need some \u001cbackend\u001d to work with later anyway and this is convenient and it\u0019s free as there is no real database to worry about. It\u0019s just data in memory which reset each time the app restarts.\r\n\r\nYou can install node here: https://nodejs.org/en/download/\r\n\r\nAnd I think the rest of the video is pretty straightforward. And you can follow it step by step.\r\n\r\nThe only caveat is that when he installs modules, you must also use the same version he uses. So in the video, DO NOT follow his exact same steps. \r\n\r\nWhere he does (for example) \u001cnpm i joi\u001d you MUST do \u001cnpm i joi@13.1.0\u001d Because to follow his steps you must use the same module versions because they do change. For example I am using Joi 17.4.2 and it is very, very different. Don\u0019t waste time here learning the changes, it\u0019s just different. Simply follow the video exactly and try to get as much from it as you can.\r\n\r\nThe goal is to learn node.js, understand exactly what is a REST API, and also have some backend that you can work with for future steps. Because eventually we will want to have some management portal to \u001cconsume\u001d the REST API. And allow a user to do the add/edit/delete actions in a browser. So to work on that next, you will need a backend to supply data.","Code":""},"Set up project":{"Info":"Installed node.js from - https://nodejs.org/en/download/\r\n\r\nThen from cmd in project file entered \"npm init --yes\", which created the packaged json file. \r\n\r\nnpm here is the node package manager.\r\n\r\nThen installed express with \"npm i express\" (I GOT CURRENT VERSION NOT HIS OOPS)\r\n\r\nThen created a file index.js in visual studio code, created files and got server going to respond to api get with an array and hello world depending on the api address\r\n\r\nThen installed nodemon so that each time file updated the server doesnt have to be stopped and restarted. (INSTALLED NODEMON 1.14.11 as per videeo). \r\n\r\nThen configured the ports so that its not a fixed port of 3000 as it will be dynamically assigned by the hosting environment. Can use an environment variable, its value is set outside the application.\r\nWe use the process object to do this. We can then set the port in cmd with \"set PORT=5000\". \r\n\r\nTo send post requests, must use chrome postman. Google then click add to chrome. This is now depreciated.\r\n\r\nTo create complex request validation can use the package joi. npm i joi@13.1.0.\r\n\r\n\r\n","Code":""},"Create portal to manage cloud":{"Info":"We need to create some sort of portal to manage the new cloud and access metrics and things like that.\r\n\r\nSo what I would like you to try to create is a simple JavaScript front end to manage the dummy customers that you have created. So there are like 100's of examples (most pretty bad) but very first thing, we need  some form to manage these customers. Add them, deleted them, change values. Something should look a bit like this:\r\n\r\nI don't know if it was in the video or not, but in your node app (in app.js or index.js or whatever) you can add a statement like\n \n\napp.use(express.static('resources')); Then create a \"resources\" subfolder in your project, and any files in there will be served from the website at the root. So if you add index.html into the resources folders, you can access it via http://localhost:3000/index.html. This makes the ajax much easier as you are not allowed to ajax to a different website normally (i.e. by default). So if you create your UI in here, it can access the API you created very easily.\r\n\r\nSo I would like something that looks similar to the above image (i.e. buttons to add. delete and edit records). And does AJAX to a REST api (i.e. the customer node app you created). \r\n\r\nI would prefer you use jquery https://jquery.com/ to make it easier. It has many helper functions  - https://jquery.com/\r\n\r\nAnd you make it look pretty, I would prefer you use something like https://getbootstrap.com/ as this is a really easy way to make some really nice looking buttons and menus and tables and stuff\n","Code":"To do:\r\nCreate front end with Javascript(Jquery):\r\n- So an index.html site, with a form that had the ability to add, remove and edit entries to customers object in memory.\r\n- Must use JQuery\r\n- Must used Ajax to a restapi - (Ajax is a set of web development techniques that uses various web technologies on the client-side to create asynchronous web applications. With Ajax, web applications can send and retrieve data from a server asynchronously without interfering with the display and behaviour of the existing page)\r\n- Then use Bootstrap to style\r\n\r\nTasks done:\r\n- Installed jquery with \"npm i jquery\"\r\n- Created index.html doc in resources file\r\n- Added app.use(express.static('resources')); to index.js and accessed site via http://localhost:3000/index.html. \r\n- Installed Bootstrap with \"npm i bootstrap\"\r\n- Installed Bootstrap Icons - \"npm i bootstrap-icons\"\r\n- Installed jsdom with \"npm i jsdom\" (NOT USING)\r\n\r\n[{\"id\":\"A4S1P7T99YE1TCJG1HGCNHJ1QK712Z4DMQEMRPH2\",\r\n\"name\":\"Testy\",\r\n\"created\":\"2021-09-09T14:52:32.524Z\",\r\n\"support_end\":\"2018-04-01T18:30:00.000Z\",\r\n\"state\":1},{\"id\":\"A4S1P7T99YE1TCJG2HGCNHJ1QK712Z4DMQEMRPH2\",\"name\":\"Testy\",\"created\":\"2021-09-10T12:00:50.257Z\",\"support_end\":\"2018-04-01T18:30:00.000Z\",\"state\":1},{\"id\":\"EQEARN380XP5H132M52ET9S76TNEYEPGGS67W6R1\",\"name\":\"cobalt\",\"created\":\"2021-09-11T10:10:11.422Z\",\"support_end\":\"2021-09-11T07:59:44\",\"state\":1}]\r\n\r\nref: \"hi\",\r\n            id: \"hi\",\r\n            name: \"hi\",\r\n            created: \"hi\",\r\n            support_end: \"hi\",\r\n            state: \"hi\"\r\n        }"}}},"Eset":{"Products":{"List":{"Info":"ESET Home Integration\r\nEset Smart Security Premium (ESSP)\r\nEset Internet Security\r\nEset NOD32 Antivirus\r\nMyEset\r\n\u0000","Code":"\u0000"},"Eset Smart Security Premium (ESSP)":{"Info":"Eset Smart Security Premium (ESSP)\r\nLiveGuard(Integration of EDTD (Eset Dynamic Threat Detection) in ESSP)\r\nEset Secure Data  - The Encryption element of Eset Smart Security\r\nSecure all Browsers - Hardens the browser\r\n\r\n\u0000","Code":"Includes: \r\nAntivirus\r\nAntispyware\r\nAnti-Phishing\r\nExploit Blocker\r\nScript-Based Attack Protection\r\nRandomware Shield\r\nUEFI Scanner\r\nAdvanced Machine Learning\r\nHIPS\r\nWMI Scanner\r\nSystem Registry Scanner\r\nParental Control\r\nFirewall\r\nAntispam\r\nNetwork Attack Protection\r\nBotnet Protection\r\nBanking & Payment Protection\r\nNetwork Inspector (The new Connected Home)\r\nEset Secure Data\r\nLiveGuard\r\nEset Password Manager\u0000"},"Eset Internet Security":{"Info":"Eset Internet Security\r\n\r\n","Code":"Includes: \r\nAntivirus\r\nAntispyware\r\nAnti-Phishing\r\nExploit Blocker\r\nScript-Based Attack Protection\r\nRandomware Shield\r\nUEFI Scanner\r\nAdvanced Machine Learning\r\nHIPS\r\nWMI Scanner\r\nSystem Registry Scanner\r\nParental Control\r\nFirewall\r\nAntispam\r\nNetwork Attack Protection\r\nBotnet Protection\r\nBanking & Payment Protection\r\nNetwork Inspector"},"Eset NOD32 Antivirus":{"Info":"Eset NOD32 Antivirus\r\n\u0000","Code":"Includes: \r\nAntivirus\r\nAntispyware\r\nAnti-Phishing\r\nExploit Blocker\r\nScript-Based Attack Protection\r\nRandomware Shield\r\nUEFI Scanner\r\nAdvanced Machine Learning\r\nHIPS\r\nWMI Scanner\r\nSystem Registry Scanner\u0000"},"Eset Home":{"Info":"Eset Home\r\n\r\nLogin and account integration\r\n\r\nWeb portal and Android and IOS application for users. Not security itself but fulfills needs. \r\n\r\nCan manage licences, who is using and which devices. Data of expiration of licence. Manager device.\u0000","Code":"\u0000"}},"Eset Research UK Products":{"List":{"Info":"","Code":""}}}}